---
layout: default
title: thread
parent: OS
---

## 들어가며
OS 카테고리의 [process](https://hotkimho.github.io/docs/OS/process/) 글의 내용이 포함되어 있습니다.  


스레드에서 발생하는 `동시성 문제`를 표현하는 `식사하는 철학자`([philosophers](https://github.com/hotkimho/42cursus/tree/master/philosophers))
를 `멀티 스레드`, `멀티 프로세스`를 이용해 해결한 코드입니다.

# Thread
## thread는 무엇인가??
스레드가 어떤건지 결론부터 말하면 `프로세스`내의 명령을 실행하는 주체입니다.

`운영체제`는 프로그램이 실행되면 `프로세스`의 형태로 `RAM(메인 메모리)`에 `PCB(Process Control Block)` 
와 함께 생성합니다. 그리고 프로세스 또한 내부의 `스레드`를 생성하여 작업을 실행합니다. 그래서 프로세스는 최소 `1개`의 스레드를 무조건 가지며 
이 스레드를 `메인 쓰레드`라고도 합니다.  

게임에 비유하여 설명하면, `쿠키런`이라는 게임을 실행하면 쿠키런이 `PCB`와 함께 메인 메모리에 올라갑니다. 이를 `인스턴스화`라고 합니다. 
그럼 다시 프로세스는 쿠키런에 대한 작업을 쓰레드에게 시키며 운영체제가 프로세스를 만들면서 `PCB`를 만들듯 쓰레드를 
생성하며 `TCP(Thread Control Black)`를 생성합니다. 하지만 PCB에 비해 담고있는 정보는 적습니다. 그리고 쓰레드를 TCP에 의해 관리합니다.  

## thread(process)가 실행되는 과정
저희가 사용하는 PC의 프로세스 개수를 세면 얼마나 나올까요? 제 PC에서는 약 100개였습니다. 
그럼 만약 `각 프로세스`에서 `4개의 스레드`를 사용한다면 어떨까요? 약 400개의 스레드가 있고 운영체제는 이 명령들을 다 실행해야 합니다.

### 시분할 방식
프로세스는 실행할려면 cpu를 선점하고 `일정 시간(Timeslice)`만큼 실행합니다. 위 글처럼 100개의 프로세스를 운영체제는 어떻게 처리할까요?

운영체제는 `스케쥴링 알고리즘`으로 `Queue`에 프로세스들의 우선순위를 고려하여 배치합니다(`Process`글에 적어놔서 간단히 설명합니다) 
`프로그램의 상태(준비, 대기)Queue`는 여러개로 구성되고 이들 중 우선순위가 높은 프로세스가 실행됩니다(준비 -> 실행) 이를 `dispatch` 라고 합니다. 
즉 100개의 프로세스들이 `Queue`에 `대기/준비`하다가 실행(dispatch)되고 그 실행되는 시간은 운영체제가 준 `TimeSlice` 만큼 실행됩니다. 
cpu의 코어 수 만큼 프로세스들이 실행됩니다!  

프로세스들이 어떻게 운영체제에 의해 시간을 받아 실행하는지 알았습니다. 다시 쓰레드로 돌아오겠습니다.

프로레스가 운영체제에 의해 시간을 받아 실행하면, 프로세스는 안에 있는 스레드에게 작업을 위임합니다. 만약 스레드 또한 1개가 아니라 여러 개면 
프로세스또한 쓰레드를 관리하며 실행시킵니다.

## PCB, TCB
### PCB
운영체제가 100(개수는 예시입니다)개의 프로세스들에게 `TimeSlice`를 주고 실행하고 `바로 다른 프로세스를 실행합니다.` 근데 여기서 궁금한 점이 있습니다. 
`100개의 프로세스가 하나씩 완료되는게 아닌 모두 조금씩 실행`되는 방식입니다. 운영체제는 다른 프로세스들이 어디까지 명령을 실행했고 어디서 실행해야 하는지 어떻게 알까요? 
그 내용은 PCB에 저장되어 있습니다. 운영체제는 PCB의 정보를 확인하여 알맞게 프로세스들을 실행시킵니다.

### TCB
프로세스들의 정보가 담긴 영역이 `PCB`이고 쓰레드의 정보를 담은 영역은 `TCB(Thread Control Block)`입니다.

TCB는 프로세스가 관리합니다. 쓰레드가 여러 개면 어떻게 될까요? 위와 같은 문제가 생길 수 있습니다. 여러 개의 쓰레드가 실행되고 
`각각의 쓰레드들 또한 어디까지 실행했으며 어디서부터 실행`할지를 알고 있어야 합니다. 여기선 프로세스가 운영체제의 역할을 대신하며 관리합니다.

### PCB, TCB의 차이
둘의 담기는 정보의 양이 다릅니다. TCB가 프로세스 내부에 저장되는 영역으로 PCB에 비해 크기가 작습니다.  

일을 처리하는 방식중 `멀티 프로세싱`, `멀티 스레드`방식이 있습니다. 이름 그대로 프로세스를 여러개, 스레드를 여러개로 분리하여 실행하는 방식입니다.
둘의 큰 차이는 무엇일까요?? 이후에 글을 쓸 예정이라 간단히 적겠습니다. 

운영체제는 `하나의 프로세스가 작업이 끝나면 다른 프로세스에게 작업할 시간을 줘야`합니다. 이를 `Context Switching(문맥 교환)` 이라고 합니다. 
프로세스 또한 `다른 스레드에게 작업할 시간을 할당`해야 합니다. 여기서 중요한점은 `PCB는 정보가 많아 무겁고`, `TCB는 PCB에 비해 정보가 적어 
Context Switching`이 드는 비용이 가볍(빠름)습니다. 이를 `오버헤드 비용이 크다`라고 합니다. 물론 이게 `실행하는 속도를 의미하는건 아닙니다.` 말 그대로 
`Context Switching`에 걸리는 시간을 의미합니다.