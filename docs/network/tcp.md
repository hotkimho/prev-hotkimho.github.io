---
layout: default
title: Tcp
parent: Network
---

# 들어가며
개인적인 생각이 많이 들어가 있습니다. 제가 적은 내용이 무조건 맞다고 말할 수 없습니다.  

# TCP가 신뢰성인 이유
흔히 `TCP`는 신뢰성이 있다 라고 표현하고 `UDP`는 신뢰성이 없다라고 얘기합니다. 그럼 왜 TCP가 신뢰성이 있다는 걸까요??  

TCP에 대해 검색을 하면 많은 분들이 TCP는 `통신`을 하려면 `3 way handshake` 방식을 사용하여 연결하기 때문에 신뢰성이 있다고 표현합니다. 제 개인적인 생각으로는 `3 way handshake`는 연결하는 방법이지 신뢰성을 보장한다고 생각하지 않습니다. 3번의 요청/응답을 통해 연결이 성공/실패 해도 연결 상태만 바뀔뿐 전송된 데이터의 안전을 보장해주지 않습니다.  

제가 생각하는 TCP가 신뢰성 이유는 2가지라고 생각합니다(주관적, 배움에 따라 더 많아질 수 있습니다)
- 패킷 손실 문제와 패킷 수신 순서에 대한 문제를 해결합니다.(흐름제어)
- 체크섬을 이용하여 수신된 데이터에 문제가 있으면 재수신을 요청합니다.

### 패킷손실 및 패킷 수신 순서
`네트워크 정체`는 네트워크에서 `한 연결에 대해 처리`할 수 있는 `데이터의 양이 초과`한 경우 발생합니다. 예를 들면 100Mbps 대역폭의 연결에서 1Gbps의 데이터를 전송할 수 없습니다. 100Mbps는 빠르게 포화되고 초과되는 데이터는 `삭제`될 것입니다.  

그래서 TCP는 데이터의 전송 속도를 조정하여, `흐름 제어(Stop And Wait, Sliidng Window)`이라는 방식을 사용해 손실된 패킷을 최소로 유지하며 데이터를 전송합니다.  

TCP는 `연결이 힘든 네트워크에서 취약`합니다. 예를 들면 Wi-FI 사용하는데 연결이 됐다 끊겼다 하는 경우가 많습니다. TCP는 `3 way handshake`방식으로 3번의 요청/응답을 하는데 연결이 자구 끊기는 이러한 상황에서 TCP는 `취약`하다고 말할 수 있습니다.  
만약 데이터를 전송하던 중 다시 라우팅되어 `네트워크 경로가 바뀌면` 어떻게 될까요? 이러면 수신 받는 쪽에서는 `받는 패킷의 순서`가 깨지게 될겁니다. 하지만 TCP는 다행이 `순서 없는 패킷을 정리해 순차적`으로 처리 합니다.

### 체크섬
TCP는 `수신된 데이터에 오류`가 있는지 검사하기 위해 체크섬을 사용합니다. 송신자는 체크섬 알고리즘을 사용해 계산한 체크섬을 `TCP헤더에 포함`하여 송신하고 수신자는 `헤더에 있는 체크섬 알고리즘`을 이용해 수신된 데이터를 확인하여 오류 여부를 파악합니다.

# 3 way handshake
TCP 연결은 클라이언트-서버간 `3 way handshake`(이하 핸드셰이크) 과정을 통해 진행됩니다. 정상적으로 연결이 이루어지면 `TCP세션`을 생성하여 서로 데이터를 주고 받습니다.  

![3handd](/docs/network/images/3hand.png)
__TCP에서 서버 클라이언트라는 관계는 없고 서로 다른 노드로 인식하지만 이해하기 쉽게 서버-클라이언트라고 표현하겠습니다__  

TCP 연결이 성립될려면 `서버는 항상 클라이언트의 요청`을 대기해야 합니다. 그리고 `3번의 요청/응답`을 진행하여 세션을 수립합니다. 

### 1. 클라이언트 -> 서버 SYN
클라이어튼는 서버에게  `SYN(Synchronize)` 플래그가 설정된 패킷을 서버로 전송합니다. 이 SYN `패킷은 앞으로 어떻게 통신할지(Sliding Window)`에 대한 설정값을 가지고 있습니다.

### 2. 서버 -> 클라이언트 SYN/ACK
서버는 클라이언트에게 `ACK(Acknowledgment)`플래그와 SYN플래그가 설정된 패킷을 클라이언트에게 전송합니다. `ACK는 1번의 SYN 플래그를 정상적`으로 `수신`했다는 의미고 `SYN 플래그는 1번의 SYN 플래그의 설정값중 앞으로 어떤 설정값을 사용할지`에 대한 내용을 담고 있습니다.

### 3. 클라이언트 -> 서버 SYN
마지막 단계로 클라이언트는 서버의 SYN 내용을 승인한다는 의미의 ACK를 보내고 핸드셰이크가 완료됩니다.  

핸드셰이크가 완료되면 `TCP세션`이 수립되며 이후 클라이언트와 서버는 데이터를 주고받을 수 있습니다. 만약 어느 한쪽에서도 데이터를 전송하지 않으면 `유휴 상태`로 남아 있고 이는 시스템에서 메모리를 계속 사용하므로 이에 따른 관리가 필요합니다.

# 수신 버퍼와 슬라이딩 윈도우(Slidding Window)
클라이언트는 서버에게 `ACK`를 보낼 때 `수신 버퍼(Receive Buffer)`에 어느 만큼의 공간을 사용할 수 있는지 서버에 알려줘야 합니다. 수신 버퍼는 `통신 중 수신 데이터`를 사용하기 위한 `메모리 공간`입니다. 수신 버퍼를 사용하면 프로그램에서 수신된 데이터를 매번 읽을 필요 없이 어느정도 데이터를 받을 수 있습니다.  

이 수신 버퍼의 크기는 ACK 패킷에 `윈도우 크기(Window Size)` 정보를 포함하여 보냅니다. 윈도우 크기는 `송신자가 수신자에게 수신 확인 필요 없이 전송할 수 있는 바이트`입니다. 예를 들어 클라이언트가 `ACK 패킷에 21024 값으로 윈도우 크기로 포함`되어 있으면 `서버는 클라이언트에게 다른 값의 윈도우 값을 가진 ACK패킷이 오기 전까지 21024Byte를 클라이언트로 보낼 수 있다는걸 의미`합니다. 만약 `윈도우 크기가 0인 ACK 패킷이 오면 수신자의 버퍼가 가득 찼다`는 의미입니다. ACK 패킷에 윈도우 크기를 받고 통신을 하고 다시 ACK 패킷에 담긴 윈도우 크기로 갱신하며 통신하는 방식을 `슬라이딩 윈도우`라고 합니다.  

![sliding_window](/docs/network/images/sliding_window.png)  
이 통신을 보면 클라이언트가 서버에게 ACK 패킷에 `윈도우 크기 3072바이트가 포함된 정보`를 보냅니다. `서버는 클라이언트가 다시 ACK 패킷을 보내 윈도우 크기를 갱신`할 때 까지 최대 3072바이트로 데이터를 전송할 수 있는걸로 확인합니다. 그래서 서버는 클라이언트로 1024바이트를 세 번 보내서 클라이언트의 수신 버퍼를 채웁니다. 다시 클리어언트는 윈도우 크기를 2048로 갱신한 ACK 패킷을 서버에 보냅니다 이 `의미는 클라이언트의 수신버퍼에서 2048Byte를 읽었다는것을 의미합니다`. 다시 서버는 1024를 두 번보내고 ACK 패킷을 기다립니다. 이렇게 통신하는 방식을 `슬라이딩 윈도우`라고 하며 계속 윈도우 크기를 갱신해가며 통신을 진행합니다. 

